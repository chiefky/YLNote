###1. 对属性修饰词了解多少（描述一下所以的属性修饰词和用法及注意事项，注意不要说漏了）
**Property的介绍**

**
**

- 简介：属性（property）是Objective-C的一项特性，用于封装对象中的数据。这一特性可以令编译器自动编写与属性相关的存取方法，并且保存为各种实例变量。

- 本质：属性的本质是实例变量与存取方法的结合。@property = ivar + getter + setter

  

**Property的特质**

1. 原子性： atomic/nonatomic
2. 读写权限： readwrite/readonly
3. 内存管理语义： assign/strong/copy/weak/unsafe_unretained
4. 方法名： getter=/setter=



**1. 原子性：atomic 与 nonatomic**

问题：什么是原子性？ 说明并比较atomic和nonatomic。 atomic是百分之百安全的吗？

- 原子性：并发编程中确保其操作具备整体性，系统其它部分无法观察到中间步骤，只能看到操作前后的结果。
- atomic：原子性的，编译器会通过锁定机制确保setter和getter的完整性。
- nonatomic：非原子性的，不保证setter和getter的完整性。
- 区别：由于要保证操作完整，atomic速度比较慢，线程相对安全；nonatomic速度比较快，但是线程不安全。atomic也不是绝对的线程安全，当多个线程同时调用set和get时，就会导致获取的值不一样。由于锁定机制开销较大，一般iOS开发中会使用nonatomic，而macOS中使用atomic通常不会有性能瓶颈。
- 拓展：要想线程绝对安全，就要使用 @synchronized同步锁。但是由于同步锁有等待操作，会降低代码效率。为了兼顾线程安全和提升效率，可采用GCD并发队列进行优化改进。get使用同步派发，set使用异步栅栏。

````objective-c
//同步锁
- (NSString *)someString {
    @synchronized(self) {
        return _someString;
    }
}
- (void)setSomeString:(NSString *)someString {
    @synchronized(self) {
        _someString = someString;
    }
}
//并发队列
_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
- (NSString *)someString {
    __block NSString *localSomeString;
    dispatch_sync(_queue, ^{
        localSomeString = _someString;
    });
    return localSomeString;
}
- (void)setSomeString:(NSString *)someString {
    dispatch_barrier_async(_queue, ^{
        _someString = someString;
    });
}
````

**2. 读写权限： readwrite 与 readonly**



读写权限不写时默认为 readwrite 。一般可在 .h 里写成readonly，只对外提供读取，在 .m 的Extension中再设置为 readwrite 可进行写入。

````objective-c
//.h文件
#import @interface MyClass : NSObject

@property (nonatomic, readonly, copy) NSString *name;

@end


//.m文件
#import "MyClass.h"

@interface MyClass()

@property (nonatomic, readwrite, copy) NSString *name;

@end


````

**3. 内存管理语义**



**3.1 关键词**

- strong：表示指向并拥有该对象。其修饰的对象引用计数会 +1 ，该对象只要引用计数不为 0 就不会销毁，强行置空可以销毁它。一般用于修饰对象类型、字符串和集合类的可变版本。
- copy：与strong类似，设置方法会拷贝一份副本。一般用于修饰字符串和集合类的不可变版， block用copy修饰。
- weak：表示指向但不拥有该对象。其修饰的对象引用计数不会增加，属性所指的对象遭到摧毁时属性值会清空。ARC环境下一般用于修饰可能会引起循环引用的对象，delegate用weak修饰，xib控件也用weak修饰。
- assign：主要用于修饰基本数据类型，如NSIteger、CGFloat等，这些数值主要存在于栈中。
- unsafe_unretained：与weak类似，但是销毁时不自动清空，容易形成野指针。



**3.2 比较 copy 与 strong**

- copy与strong：相同之处是用于修饰表示拥有关系的对象。不同之处是strong复制是多个指针指向同一个地址，而copy的复制是每次会在内存中复制一份对象，指针指向不同的地址。NSString、NSArray、NSDictionary等不可变对象用copy修饰，因为有可能传入一个可变的版本，此时能保证属性值不会受外界影响。
- 注意：若用strong修饰NSArray，当数组接收一个可变数组，可变数组若发生变化，被修饰的属性数组也会发生变化，也就是说属性值容易被篡改；若用copy修饰NSMutableArray，当试图修改属性数组里的值时，程序会崩溃，因为数组被复制成了一个不可变的版本。



**3.3 比较 assign、weak、unsafe_unretain**

- 相同点：都不是强引用。
- 不同点：weak引用的 OC 对象被销毁时, 指针会被自动清空，不再指向销毁的对象，不会产生野指针错误；unsafe_unretain引用的 OC 对象被销毁时, 指针并不会被自动清空, 依然指向销毁的对象，很容易产生野指针错误:EXC_BAD_ACCESS；assign修饰基本数据类型，内存在栈上由系统自动回收。



**4. 方法名： getter=** **与 setter=**



<> 中为方法名，通过此特质来指定存取方法的名称

````objective-c
//.h文件
@interface MyClass : NSObject

@property (nonatomic, assign, getter=isOn) BOOL on;

@end

//.m文件
@implementation MyClass

- (BOOL)isOn {
    return self.on;
}

@end
````

**Property的默认设置**

**
**

- 基本数据类型：atomic, readwrite, assign
- 对象类型：atomic, readwrite, strong
- 注意：考虑到代码可读性以及日常代码修改频率，规范的编码风格中关键词的顺序是：原子性、读写权限、内存管理语义、getter/getter。

**
**

**延伸**



我们已经知道 @property 会使编译器自动编写访问这些属性所需的方法，此过程在编译期完成，称为 自动合成 (autosynthesis)。与此相关的还有两个关键词：@dynamic 和 @synthesize。

- @dynamic：告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。即使编译器发现没有定义存取方法也不会报错，运行期会导致崩溃。
- @synthesize：在类的实现文件里可以通过 @synthesize 指定实例变量的名称。
- 注意：在Xcode4.4之前，@property 配合 @synthesize使用，@property 负责声明属性，@synthesize 负责让编译器生成 带下划线的实例变量并且自动生成setter、getter方法。Xcode4.4 之后 @property 得到增强，直接一并替代了 @synthesize 的工作。