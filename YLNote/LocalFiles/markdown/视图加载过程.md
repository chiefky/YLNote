### 视图加载过程
要混用Frame和Auto Layout，必须要搞清楚他们的作用时间和有效范围，这和视图的加载过程有很大的关系。我们在controller视图上面用auto layout添加了一个subview，并在各个系统调用声明周期方法中做了打印处理，结果如下：
viewDidLoad   
viewWillAppear 
viewWillLayoutSubviews(1)  
-updateConstraints   
updateViewConstraints
viewWillLayoutSubviews(2)
viewDidLayoutSubviews   
-layoutSubviews   
-drawRect  
viewDidAppear   
复制代码
其中前面带有“-”符号的表示的是subview视图的打印。对于viewWillLayoutSubviews出现的顺序根据使用的布局方式会有所区别，使用Frame时出现为viewWillLayoutSubviews(1)位置，使用Auto Layout时出现在viewWillLayoutSubviews(2)位置。
Auto Layout的作用范围是从第三个方法-updateConstraints开始直到viewDidLayoutSubviews完成，在这期间系统是通过view上的约束来计算view上的布局。一般我们都是在viewDidLoad里面编写页面布局代码，如果这时对一个视图同时使用了Auto Layout和Frame，我们会发现frame无效，就是因为这时布局是按照约束来计算的。如果视图的frame在布局过程中发生了改变（比如initWithFrame，使用xib都会给予初始值，但实际布局时我们可能想要更改），这时如果想获取视图的准确frame值，在viewWillAppear中是不行的，只能在自动布局生效后获取到，即我们可以再viewDidLayoutSubviews和viewDidAppear中获取frame的准确值。由上述结果也可以得出，系统的布局是优先使用Auto Layout的，但是布局的最终结果却是将约束转化成视图的frame，理解了这一点对于布局方式的选用也很重要。
要想修改布局，必须要在Auto Layout结束之后才会起作用，否则会被系统将我们的布局按照Auto Layout重新刷新。从上面我们可以看到，我们可以在子视图的-layoutSubviews和-drawRect方法里面修改子视图的布局，但是一般视图为了重用不会在自己的类里面将frame写死，这样我们只有通过controller的viewDidLayoutSubviews和viewDidAppear方法修改视图的frame。但是这样也有问题，在viewDidAppear里面修改布局，我们可以看到一个明显的延迟，系统调用次序使然，我们无法去改变。
所以我的建议就是不要对同一个视图同时使用Frame和Auto Layout去控制同一个视图。如果一个视图使用了某种布局方式，那么尽量保持统一中方式改变布局。
