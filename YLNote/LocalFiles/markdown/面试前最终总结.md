## 算法



## 循环引用

1. 循环引用的例子有哪些？
   * block内使用强持有block的对象
   * NSNotificationCenter 添加的observer（iOS8之后不会崩溃）
   * WKWebView的messageHandler
   * swift 中function 嵌套的function
2. 





## 类、元类、分类和对象

#### 概念

**类**是实例对象的描述；

**元类**是类对象的描述。

 举个例子：

 `NSObject *obj = [NSObject new];` NSObject 是 实例对象 obj 的描述，NSObject 的元类是 NSObject 类对象的描述。

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/meat_class.png" style="zoom:50%;" />

举例说明：

> 实例对象：obj表示
>
> 类对象：Obj 表示
>
> 元类对象：MetaObj表示
>
> 根元类对象：NSObjectMeat

| isa指向                        | super指向 |
| ------------------------------ | --------- |
| obj ---> Obj                   |           |
| Obj ---> MetaObj               |           |
| MetaObj ---> NSObjectMeta      |           |
| NSObjectMeta ---> NSObjectMeta |           |



### 1. crash分析

1. **设备信息**

   ```objc
   Incident Identifier: AF4F2C83-8F68-47EF-B5AA-F16B067B5DF4   // crash的ID
   CrashReporter Key:   5670de85ee1f0f3c904891536e81ec086ed4b35b   // crash 的设备ID
   Hardware Model:      iPhone8,1   // 手机的型号 (iPhone8,1代表iPhone6s  8,2 代表iPhone6s Plus)
   Process:             kidneyUser [896]   // App的名称 (该App的进程ID)
   Path:                /private/var/containers/Bundle/Application/48C71AA1-EB99-49B1-ABD7-2903DBA8E394/kidneyUser.app/kidneyUser         // APP 的位置 路径
   Identifier:          kidneyDiseaseHospitalUser // bundle ID
   Version:             1 (1.0)   // APP的版本号
   Code Type:           ARM-64 (Native) // app的应用架构
   Parent Process:      launchd [1]
   
   Date/Time:           2016-05-05 10:45:43.43 +0800      // crash发生的时间
   Launch Time:         2016-05-05 10:42:07.07 +0800    // 进入应用的时间
   OS Version:          iOS 9.3.1 (13E238)    // iOS系统的版本
   Report Version:      105
   
   
   ```

   

如果产品上线之后, 回收集大量的Crash Log日志文件, 可以对Crash文件里面的手机型号,版本号, 手机型号, iOS系统版本,进行分类, 可以获得更多的信息, 更好的解决bug甚至未知的bug具体原因, 做更好的测试

2.**异常信息**

```objc
Exception Type:  EXC_CRASH (SIGABRT)   // 异常的类型
Exception Codes: 0x0000000000000000, 0x0000000000000000  // 异常出错的代码
Exception Note:  EXC_CORPSE_NOTIFY  // 异常通知
Triggered by Thread:  0 // 异常发生的线程(0代表主线程, 其他为主线程)
```

**补充常见的Exception Codes代码类型**

Exception Codes:   常见代码有以下几种

```objc
0x8badf00d错误码：Watchdog超时，意为“ate bad food”。
0xdeadfa11错误码：用户强制退出，意为“dead fall”。
0xbaaaaaad错误码：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。                             0xbad22222错误码：VoIP应用（因为太频繁？）被iOS干掉。
0xc00010ff错误码：因为太烫了被干掉，意为“cool off”。
0xdead10cc错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock”
```

**补充常见的Exception Type异常类型的信息:**

1. **<font color="red">EXC_BAD_ACCESS</font>**：此类型是最常见的crash, 通常用于访问了不该访问的内存导致的,一般     EXC_BAD_ACCESS后面的()还会带有补充信息

SIGSEGV:通常由于重复释放对象导致, 一般在ARC以后很少见到

SIGABRT: 收到Abort信号退出, 通常Foundtion库中的容器为了保护状态正常会做一些检测, 例如插入nil到数据中等会遇到此类错误.

野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS(code=EXC_I386_GPFLT)错误。因为你访问了一块已经不属于你的内存。

SEGV(Segmentation Violation): 代表无效内存地址, 比如空指针, 未初始化指针, 栈溢出等.

SIGBUS:总栈错误, 与SIGSEGV不同的是, SIGSEGV访问的是无效的地址, 而SIGBUS访问的是有效的地址, 但是总栈访问异常(如地址对齐问题)

SIGILL: 尝试执行非法的指令, 可能不被识别或者没有权限

SIGFPE: 数学计算相关问题, 比如除零操作

SIGIPIPE: 管道另一端没有进程接手数据

2. **<font color="red"> EXC_BAD_INSTRUCTION </font>**：此类异常通常由于线程执行非法指令导致
3. <font color="red">**EXC_ARITHMETIC** </font>：除零错误会抛出此类异常
                                                   

Last Exception Backtrace: 最后异常回溯, 一般根据这个代码就能找到具体的crash问题

下面截取的是微信的crash blog

```objc
Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0:
0   libsystem_kernel.dylib            0x000000018223ff24 __psynch_cvwait + 8
1   libsystem_pthread.dylib           0x000000018230ad20 _pthread_cond_wait + 704
2   Foundation                        0x0000000182f9fdf0 -[NSCondition waitUntilDate:] + 344
3   Foundation                        0x0000000182f9ce34 -[NSConditionLock lockWhenCondition:beforeDate:] + 256
4   UIKit                             0x000000018781dbc4 -[UIKeyboardTaskQueue waitUntilAllTasksAreFinished] + 196
5   UIKit                             0x0000000187c05878 -[UIKeyboardImpl setKeyboardInputMode:userInitiated:] + 112
6   UIKit                             0x0000000187c0de44 -[UIKeyboardImpl recomputeActiveInputModesWithExtensions:] + 336
7   UIKit                             0x000000018781e8f0 -[UIKeyboardImpl setDelegate:force:] + 2292
8   UIKit                             0x0000000187817eb0 -[UIPeripheralHost(UIKitInternal) _reloadInputViewsForResponder:] + 1180
9   UIKit                             0x00000001878179e4 -[UIResponder(UIResponderInputViewAdditions) reloadInputViews] + 80
10  UIKit                             0x0000000187879670 -[UIResponder becomeFirstResponder] + 600
11  UIKit                             0x0000000187879a1c -[UIView(Hierarchy) becomeFirstResponder] + 148
12  UIKit                             0x0000000187900b34 -[UITextField becomeFirstResponder] + 64
13  UIKit                             0x00000001879b1fe4 -[UITextInteractionAssistant(UITextInteractionAssistant_Internal) setFirstResponderIfNecessary] + 256
14  UIKit                             0x00000001879b1498 -
```

我们可以看到发生Crash的线程的Crash调用栈, 从上到下分别代表调用顺序, 最上面的一个表示抛出异常的位置, 一次往下可以看到API调用顺序, 上图的信息表明本次Crash出现在[NSCondition waitUntilDate:]这个方法中(后面加的数值 我猜应该是地址偏移量O(∩_∩)O) 大概可以找到crash的具体原因(某个文件中的某个方法), 这样问题就浮出水面了, 方便产品上线后版本迭代, 修改BUG.

###2.