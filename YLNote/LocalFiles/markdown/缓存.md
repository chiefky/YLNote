## 1. iOS中文件存放的位置有哪些？

1. 程序运行期间产生的数据、资源文件 ---> **沙盒**中
2. 程序编写过程中用到的资源文件 --->**NSBundle**中

### 1.1 沙盒机制

iOS 中的沙盒机制是一种安全体系。每个iOS程序都有一个独立的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。

所有的非代码文件都要保存在此，例如属性文件plist、文本文件、图像、图标、媒体资源等。

沙盒是用来存入缓冲区的，APP关掉，缓存被自动清理。

### 1.2 NSBundle

> bundle 是一个目录，其中包含了程序会使用到的资源，这些资源包含了图像，声音，编译好的代码，nib文件（用户也会把bundle称plug-in），对应bundle，cocoa提供了类NSBundle

### 1.3 沙盒与NSBundle结构对比

**1.3.1 路径输出**

```swift
// 输出沙盒路径和bundle路径：
沙盒路径：/Users/zhangsan/Library/Developer/CoreSimulator/Devices/25BA342E-6B5A-4D01-92C8-98432A3443FC/data/Containers/Data/Application/8C27F167-5981-41EB-AD43-750560D5AD69
程序路径：/Users/zhangsan/Library/Developer/CoreSimulator/Devices/25BA342E-6B5A-4D01-92C8-98432A3443FC/data/Containers/Bundle/Application/7D804E2B-D687-47A4-A65B-0594F2DE68AA/YLNote.app

```

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/程序包路径.png" alt="img" style="zoom:50%;" />

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/沙盒路径.png" alt="img" style="zoom:50%;" />

**各路径下存储数据的特点**

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/Library目录结构.png" style="zoom:50%;" />

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/文件存储路径.png" style="zoom:67%;" />

## 2. 什么是缓存？

缓存就是本地数据存储。存储方式主要包含两种：磁盘储存和内存存储。

### 2.1 缓存的用途

离线加载，预加载，本地通讯录…等，对非网络数据，使用本地数据管理的一种，具体使用场景有很多。



###2.2 缓存按存储方式分有几种？

####2.2.1 磁盘存储

磁盘存储也就是硬盘存储，磁盘是程序的存储空间。

磁盘缓存特点：容量大、速度慢，永久存储。

iOS 为不同数据管理对存储路径做了规范如下：

1）每一个应用程序都会拥有一个应用程序沙盒。

2）应用程序沙盒就是一个文件系统目录。

沙盒根目录结构：Documents、Library、temp。

磁盘存储方式主要有文件管理和数据库。

**磁盘缓存的几种常用方式？**

| 存储方式                | 存储特点                                                     |
| ----------------------- | ------------------------------------------------------------ |
| 归档（NSKeyedArchiver） | 采用归档的形式来保存数据，该数据对象需要遵守 NSCoding 协议，并且该对象对应的类必须提供 encodeWithCoder:和 initWithCoder:方法。<br />缺点：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，如果想改动数据的某一小部分，需要解压整个数据或者归档整个数据。 |
| NSUserDefaults          | 用来保存应用程序设置和属性、用户保存的数据。用户再次打开程序或开机后这些数据仍然存在。<br />NSUserDefaults 可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、 NSDictionary。<br/> |
| 写入方式（Write ）      | 永久保存在磁盘中                                             |
| SQLite：                | 采用 SQLite 数据库来存储数据。SQLite 作为一个中小型数据库，应用 ios 中跟其他三种保存方式相比，相对复杂一些。 |



#### 2.2.2 内存存储

内存缓存，内存缓存是指当前程序运行空间。

内存缓存特点：速度快、容量小，它是供 cpu 直接读取，比如我们打开一个程序，他是运行在内存中的，关闭程序后内存又会释放。

iOS 内存分为 5 个区：栈区，堆区，全局区，常量区，代码区

**内存缓存的几种常用方式?**

- 在程序中声明的容器（数组 、字典）都可看做内存中存储。

内存布局图：

<img src="/Users/tangh/yuki/ios_project/YLNote/YLNote/LocalFiles/markdown/images/内存布局.png" alt="img" style="zoom:50%;" />

##3. 如何优化缓存

结合YYCache 背景知识：

源码中由两个主要类构成：

1）YYMemoryCache (内存缓存)

操作 YYLinkedMap 中数据， 为实现内存优化，采用双向链表数据结构实现 LRU 算法，YYLinkedMapItem 为每个子节点。

2）YYDiskCache （磁盘缓存）

不会直接操作缓存对象（sqlite/file），而是通过 YYKVStorage 来间接的操作缓存对象。



![img](https://static001.infoq.cn/resource/image/a4/26/a43bf030f4085d6e7086b5776b690526.png)



容量管理：

- ageLimit ：时间周期限制，比如每天或每星期开始清理；
- costLimit： 容量限制，比如超出 10M 后开始清理内存；
- countLimit ： 数量限制， 比如超出 1000 个数据就清理。

这里借用 YYCache 设计, 来讲述缓存优化。

### 3.1 磁盘+内存组合优化

利用内存和磁盘特性，融合各自优点，整合如下：



![img](https://static001.infoq.cn/resource/image/f2/a6/f2b694cb3e068f83a34754c0dbd78fa6.png)



- APP 会优先请求内存缓冲中的资源；
- 如果内存缓冲中有，则直接返回资源文件， 如果没有的话，则会请求资源文件，这时资源文件默认资源为本地磁盘存储，需要操作文件系统或数据库来获取；
- 获取到的资源文件，先缓存到内存缓存，方便以后不再重复获取，节省时间。
- 然后就是从缓存中取到数据然后给 app 使用。



这样就充分结合两者特性，利用内存读取快特性减少读取数据时间。



YYCache 源码解析：



```objective-c
 1- (id<NSCoding>)objectForKey:(NSString *)key {
 2    // 1.如果内存缓存中存在则返回数据
 3    id<NSCoding> object = [_memoryCache objectForKey:key];
 4    if (!object) {
 5        // 2.若不存在则查取磁盘缓存数据
 6        object = [_diskCache objectForKey:key];
 7        if (object) {
 8            // 3.并将数据保存到内存中
 9            [_memoryCache setObject:object forKey:key];
10        }
11    }
12    return object;
13}

```

复制代码



### 3.2 内存优化 — 提高内存命中率

但是我们想在基础上再做优化，比如想让经常访问的数据保留在内存中，提高内存的命中率，减少磁盘的读取，那怎么做处理呢？ — LRU 算法。



![img](https://static001.infoq.cn/resource/image/81/95/8103e841eccaef4ca035c2653af9d495.png)



LRU 算法：我们可以将链表看成一串数据链，每个数据是这个串上的一个节点，经常访问的数据移动到头部，等数据超出容量后从链表后面的一些节点销毁，这样经常访问数据在头部位置，还保留在内存中。



链表实现结构图：



![img](https://static001.infoq.cn/resource/image/09/eb/09b0f1abe6ad6c0ed92c2dc79f13c4eb.png)



YYCache 源码解析：



```objective-c
 1/**
 2 A node in linked map.
 3 Typically, you should not use this class directly.
 4 */
 5@interface _YYLinkedMapNode : NSObject {
 6    @package
 7    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic
 8    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic
 9    id _key;
10    id _value;
11    NSUInteger _cost;
12    NSTimeInterval _time;
13}
14@end
15@implementation _YYLinkedMapNode
16@end
17/**
18 A linked map used by YYMemoryCache.
19 It's not thread-safe and does not validate the parameters.
20 Typically, you should not use this class directly.
21 */
22@interface _YYLinkedMap : NSObject {
23    @package
24    CFMutableDictionaryRef _dic; // do not set object directly
25    NSUInteger _totalCost;
26    NSUInteger _totalCount;
27    _YYLinkedMapNode *_head; // MRU, do not change it directly
28    _YYLinkedMapNode *_tail; // LRU, do not change it directly
29    BOOL _releaseOnMainThread;
30    BOOL _releaseAsynchronously;
31}
32
33/// Insert a node at head and update the total cost.
34/// Node and node.key should not be nil.
35- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;
36
37/// Bring a inner node to header.
38/// Node should already inside the dic.
39- (void)bringNodeToHead:(_YYLinkedMapNode *)node;
40
41/// Remove a inner node and update the total cost.
42/// Node should already inside the dic.
43- (void)removeNode:(_YYLinkedMapNode *)node;
44
45/// Remove tail node if exist.
46- (_YYLinkedMapNode *)removeTailNode;
47
48/// Remove all node in background queue.
49- (void)removeAll;
50
51@end

```

_YYLinkedMapNode *_prev 为该节点的头指针，指向前一个节点；



_YYLinkedMapNode *_next 为该节点的尾指针，指向下一个节点。



头指针和尾指针将一个个子节点串连起来，形成双向链表。



来看下 bringNodeToHead:的源码实现，它是实现 LRU 算法主要方法，移动 node 子结点到链头。（详细已注释在代码中）



```objective-c
 1- (void)bringNodeToHead:(_YYLinkedMapNode *)node {
 2    if (_head == node) return; // 如果当前节点是链头，则不需要移动
 3
 4    // 链表中存了两个指向链头(_head)和链尾(_tail)的指针，便于链表访问
 5    if (_tail == node) {
 6        _tail = node->_prev; // 若当前节点为链尾，则更新链尾指针
 7        _tail->_next = nil; // 链尾的尾节点这里设置为nil
 8    } else {
 9        // 比如：A B C 链表, 将 B拿走，将A C重新联系起来
10        node->_next->_prev = node->_prev; // 将node的下一个节点的头指针指向node的上一个节点，
11        node->_prev->_next = node->_next; // 将node的上一个节点的尾指针指向node的下一个节点
12    }
13    node->_next = _head; // 将当前node节点的尾指针指向之前的链头，因为此时node为最新的第一个节点
14    node->_prev = nil; // 链头的头节点这里设置为nil
15    _head->_prev = node; // 之前的_head将为第二个节点
16    _head = node; // 当前node成为新的_head
17}

```

其他方法就不挨个举例了，具体可翻看源码，这些代码结构清晰，类和函数遵循单一职责，接口高内聚，低耦合，是个不错的学习示例！

### 3.3 磁盘优化 — 数据分类存储

YYDiskCache 是一个线程安全的磁盘缓存，基于 sqlite 和 file 来做的磁盘缓存，我们的缓存对象可以自由的选择存储类型。



下面简单对比一下：



- sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。
- file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。



所以 YYDiskCache 使用两者配合，灵活的存储以提高性能。



另外，YYDiskCache 具有以下功能：



- 它使用 LRU(least-recently-used) 来删除对象。
- 支持按 cost，count 和 age 进行控制。
- 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。
- 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。



YYCache 源码解析：



```objective-c
 1// YYKVStorageItem 是 YYKVStorage 中用来存储键值对和元数据的类
 2// 通常情况下，我们不应该直接使用这个类
 3@interface YYKVStorageItem : NSObject
 4@property (nonatomic, strong) NSString *key;                ///< key
 5@property (nonatomic, strong) NSData *value;                ///< value
 6@property (nullable, nonatomic, strong) NSString *filename; ///< filename (nil if inline)
 7@property (nonatomic) int size;                             ///< value's size in bytes
 8@property (nonatomic) int modTime;                          ///< modification unix timestamp
 9@property (nonatomic) int accessTime;                       ///< last access unix timestamp
10@property (nullable, nonatomic, strong) NSData *extendedData; ///< extended data (nil if no extended data)
11@end
12
13
14/**
15 YYKVStorage 是基于 sqlite 和文件系统的键值存储。
16 通常情况下，我们不应该直接使用这个类。
17
18 @warning 
19  这个类的实例是 *非* 线程安全的，你需要确保
20  只有一个线程可以同时访问该实例。如果你真的
21  需要在多线程中处理大量的数据，应该分割数据
22  到多个 KVStorage 实例（分片）。
23 */
24@interface YYKVStorage : NSObject
25
26#pragma mark - Attribute
27@property (nonatomic, readonly) NSString *path;        /// storage 路径
28@property (nonatomic, readonly) YYKVStorageType type;  /// storage 类型
29@property (nonatomic) BOOL errorLogsEnabled;           /// 是否开启错误日志
30
31#pragma mark - Initializer
32- (nullable instancetype)initWithPath:(NSString *)path type:(YYKVStorageType)type NS_DESIGNATED_INITIALIZER;
33
34#pragma mark - Save Items
35- (BOOL)saveItem:(YYKVStorageItem *)item;
36...
37
38#pragma mark - Remove Items
39- (BOOL)removeItemForKey:(NSString *)key;
40...
41
42#pragma mark - Get Items
43- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;
44...
45
46#pragma mark - Get Storage Status
47- (BOOL)itemExistsForKey:(NSString *)key;
48- (int)getItemsCount;
49- (int)getItemsSize;
50
51@end

```

我们只需要看一下 YYKVStorageType 这个枚举，它决定着 YYKVStorage 的存储类型。

YYKVStorageType：



```objc
 1/**
 2 存储类型，指示“YYKVStorageItem.value”存储在哪里。
 3
 4 @discussion
 5  通常，将数据写入 sqlite 比外部文件更快，但是
 6  读取性能取决于数据大小。在测试环境 iPhone 6s 64G，
 7  当数据较大（超过 20KB）时从外部文件读取数据比 sqlite 更快。
 8 */
 9typedef NS_ENUM(NSUInteger, YYKVStorageType) {
10    YYKVStorageTypeFile = 0, // value 以文件的形式存储于文件系统
11    YYKVStorageTypeSQLite = 1, // value 以二进制形式存储于 sqlite
12    YYKVStorageTypeMixed = 2, // value 将根据你的选择基于上面两种形式混合存储
13};

```



### 3.4 小结

这里说了 YYCache 几个主要设计优化之处，其实细节上也有很多不错的处理，比如：

1）线程安全

如果说 YYCache 这个类是一个纯逻辑层的缓存类（指 YYCache 的接口实现全部是调用其他类完成），那么 YYMemoryCache 与 YYDiskCache 还是做了一些事情的（并没有 YYCache 当甩手掌柜那么轻松），其中最显而易见的就是 YYMemoryCache 与 YYDiskCache 为 YYCache 保证了线程安全。

YYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore，上文已经给出了作者选择这些锁的原因。

2）性能

YYCache 中对于性能提升的实现细节：

- 异步释放缓存对象
- 锁的选择
- 使用 NSMapTable 单例管理的 YYDiskCache
- YYKVStorage 中的 _dbStmtCache
- 甚至使用 CoreFoundation 来换取微乎其微的性能提升